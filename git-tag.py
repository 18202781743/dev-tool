import sys
import argparse
import subprocess
import re
import os
import logging
import json
from datetime import datetime

class Colors:
    RESET = '\033[0m'
    RED = '\033[31m'      # é”™è¯¯
    YELLOW = '\033[33m'   # è­¦å‘Š
    GREEN = '\033[32m'    # æˆåŠŸä¿¡æ¯
    GRAY = '\033[90m'     # è°ƒè¯•ä¿¡æ¯

class ColoredFormatter(logging.Formatter):
    COLORS = {
        logging.ERROR: Colors.RED,
        logging.WARNING: Colors.YELLOW,
        logging.INFO: Colors.GREEN,
        logging.DEBUG: Colors.GRAY,
    }

    def format(self, record):
        # å…ˆæ ¼å¼åŒ–æ¶ˆæ¯
        formatted = super().format(record)
        
        # åªåœ¨ç»ˆç«¯ä¸­æ˜¾ç¤ºé¢œè‰²ï¼Œæ•´è¡Œåº”ç”¨é¢œè‰²
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            color = self.COLORS.get(record.levelno, '')
            if color:
                formatted = f"{color}{formatted}{Colors.RESET}"
        
        return formatted

# å…¨å±€å‚æ•°
class ArgsInfo:
    def __init__(self):
        # é»˜è®¤å€¼
        self.projectName = "xxxtools" # é¡¹ç›®åç§°
        self.projectBranch = "master" # é¡¹ç›®åˆ†æ”¯
        self.projectTag = "1.0.0" # è‡ªå®šä¹‰tag
        self.autoGeneratedProjectTag = False # tagæ˜¯å¦è‡ªåŠ¨ç”Ÿæˆ
        self.projectOrg = "linuxdeepin"
        self.projectReviewers = []
        self.verbose = False # æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†è¾“å‡º
        self.quiet = False # æ˜¯å¦é™é»˜æ¨¡å¼ï¼ˆä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
        # ä»é…ç½®æ–‡ä»¶è¯»å–å‚æ•°
        self.projectRootDir = "~/.cache/git-tag-dir" # é»˜è®¤å€¼
        config_path = os.path.expanduser('~/.config/dev-tool/git-tag-config.json')
        with open(config_path) as f:
            config = json.load(f)
        
        # Gitä¿¡æ¯
        self.githubID = config['git']['githubID']     # github ç”¨æˆ·id
        self.debEmail = config['git']['debEmail']     # debian æ‰“åŒ…é‚®ç®±

        # ä»é…ç½®æ–‡ä»¶ä¸­è¯»å–å…¶ä»–å‚æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if 'params' in config:
            params = config['params']
            self.projectBranch = params.get('projectBranch', self.projectBranch)
            self.projectOrg = params.get('projectOrg', self.projectOrg)
            self.projectReviewers = params.get('projectReviewers', self.projectReviewers)
            self.projectRootDir = params.get('projectRootDir', self.projectRootDir)

argsInfo = ArgsInfo()

def setup_logging():
    level = logging.DEBUG if argsInfo.verbose else logging.INFO
    
    # åˆ›å»ºlogger
    logger = logging.getLogger(__name__)
    logger.setLevel(level)
    
    # é¿å…é‡å¤æ·»åŠ handler
    if logger.handlers:
        logger.handlers.clear()
    
    # åˆ›å»ºæ§åˆ¶å°å¤„ç†å™¨
    handler = logging.StreamHandler()
    handler.setLevel(level)
    
    # ä½¿ç”¨å½©è‰²æ ¼å¼åŒ–å™¨
    formatter = ColoredFormatter(
        fmt='[%(asctime)s] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger

def find_config_file(filename):
    """æŸ¥æ‰¾é…ç½®æ–‡ä»¶ï¼Œå…ˆåœ¨å½“å‰ç›®å½•æŸ¥æ‰¾ï¼Œç„¶ååœ¨~/.config/dev-tool/packagesæŸ¥æ‰¾"""
    # æ£€æŸ¥å½“å‰ç›®å½•
    local_path = os.path.join(os.getcwd(), filename)
    if os.path.exists(local_path):
        return local_path
    
    # æ£€æŸ¥packagesç›®å½•
    packages_path = os.path.expanduser(f'~/.config/dev-tool/packages/{filename}')
    if os.path.exists(packages_path):
        return packages_path
    
    # æ£€æŸ¥é»˜è®¤configç›®å½•
    config_path = os.path.expanduser(f'~/.config/dev-tool/{filename}')
    if os.path.exists(config_path):
        return config_path
    
    raise FileNotFoundError(f"Could not find config file {filename} in any of: current directory, ~/.config/dev-tool/packages/, ~/.config/dev-tool/")

logger = setup_logging()

def createRepo():
    try:
        result = subprocess.run(
            ["git", "clone", "https://github.com/" + argsInfo.projectOrg + "/" + argsInfo.projectName + ".git"],
            check=True,
            capture_output=not argsInfo.verbose,
            text=True
        )
        logger.info(f"Successfully cloned repository: {argsInfo.projectOrg}/{argsInfo.projectName}")
        if not argsInfo.verbose:
            logger.debug(f"Clone output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to clone repository {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.error(f"Error: {e.stderr}")
        raise

def initRepo():
    try:
        # Add github remote
        result = subprocess.run(
            f"git remote add github https://github.com/{argsInfo.githubID}/{argsInfo.projectName}.git",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("Successfully added github remote")
        logger.debug(f"Add remote output: {result.stdout}")

        # Set default repo
        result = subprocess.run(
            ["gh", "repo", "set-default", f"{argsInfo.projectOrg}/{argsInfo.projectName}"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info(f"Successfully set default repository to {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.debug(f"Set default repo output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize repository: {e.stderr}")
        raise
    
def fetchLastTag():
    try:
        # Fetch from origin
        fetch_result = subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Fetch output: {fetch_result.stdout}")

        # Get last tag
        tag_result = subprocess.run(
            "git describe --tags --abbrev=0",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        lastTag = tag_result.stdout.strip()
        logger.info(f"Found last tag: {lastTag}")
        return lastTag
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to fetch/get last tag: {e.stderr}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in fetchLastTag: {str(e)}")
        return None

def autoGeneratedTagByLastTag(lastTag):
    increment_part = 'patch'  # é»˜è®¤é€’å¢éƒ¨åˆ†ä¸º 'patch' {major}.{minor}.{patch}
    parts = lastTag.split('.')
    if len(parts) != 3:
        raise ValueError(f"æ— æ•ˆçš„ç‰ˆæœ¬å·æ ¼å¼ '{lastTag}'ï¼Œåº”ä¸º major.minor.patch")

    try:
        major = int(parts[0])
        minor = int(parts[1])
        patch = int(parts[2])
    except ValueError:
        raise ValueError(f"ç‰ˆæœ¬å·å„éƒ¨åˆ†å¿…é¡»ä¸ºæ•´æ•° '{lastTag}'")
        
    if increment_part == 'patch':
        patch += 1
    elif increment_part == 'minor':
        minor += 1
        patch = 0
    elif increment_part == 'major':
        major += 1
        minor = 0
        patch = 0
    else:
        raise ValueError(f"æ— æ•ˆçš„é€’å¢éƒ¨åˆ† '{increment_part}'ï¼Œåº”ä¸º 'major', 'minor', æˆ– 'patch'")

    return f"{major}.{minor}.{patch}"

def initTagPR():
    try:
        # Git operations
        subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            ["git", "reset", "--hard", f"origin/{argsInfo.projectBranch}"],
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            f"git checkout -B dev-changelog origin/{argsInfo.projectBranch}",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Set DEBEMAIL environment variable
        os.environ["DEBEMAIL"] = argsInfo.debEmail

        lastTag = fetchLastTag()
        logger.info(f"Last Tag: {lastTag}")

        if argsInfo.autoGeneratedProjectTag:
            argsInfo.projectTag = autoGeneratedTagByLastTag(lastTag)
        
        logger.info(f"Project Tag: {argsInfo.projectTag}")

        # Get commit info
        commit_result = subprocess.run(
            ["git", "log", "--pretty=format:%s", "--no-merges", f"{lastTag}..HEAD"],
            check=True,
            capture_output=True,
            text=True
        )
        commitInfo = commit_result.stdout
        if not commitInfo:
            commitInfo = f"Release {argsInfo.projectTag}"

        logger.info(f"Changelog Info: {commitInfo}")

        # Process changelog
        with subprocess.Popen(
            ["xargs", "-d", "\n", "-I", "{}", "dch", "-v", argsInfo.projectTag, "{}"],
            stdin=subprocess.PIPE,
            text=True
        ) as dch_process:
            dch_process.communicate(input=commitInfo)

        subprocess.run(
            "dch -r ''",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Commit changes
        subprocess.run(
            ["git", "commit", "-a", "-m", f"chore: bump version to {argsInfo.projectTag}\n\nupdate changelog to {argsInfo.projectTag}"],
            check=True,
            capture_output=True,
            text=True
        )

    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in initTagPR: {str(e)}")
        raise

def createTagPR():
    try:
        # Check if forked repo exists
        fork_check = subprocess.run(
            ["gh", "repo", "view", f"{argsInfo.githubID}/{argsInfo.projectName}"],
            capture_output=True,
            text=True
        )
        
        if fork_check.returncode != 0:
            # Fork the repo if not exists
            logger.info(f"Forking repository {argsInfo.projectOrg}/{argsInfo.projectName}")
            fork_result = subprocess.run(
                ["gh", "repo", "fork", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "--clone=false"],
                check=True,
                capture_output=True,
                text=True
            )
            logger.debug(f"Fork output: {fork_result.stdout}")

        # Push to github
        push_result = subprocess.run(
            "git push github dev-changelog -f",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Push output: {push_result.stdout}")

        # Prepare PR creation command
        args = [
            "gh", "pr", "create",
            "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}",
            "--head", f"{argsInfo.githubID}:dev-changelog",
            "--base", argsInfo.projectBranch,
            "--title", f"chore: bump version to {argsInfo.projectTag}",
            "--body", f"update changelog to {argsInfo.projectTag}"
        ]
        
        # Add reviewers if specified
        if argsInfo.projectReviewers:
            reviewers = []
            for value in argsInfo.projectReviewers:
                reviewers.extend(['--reviewer', value])
            args.extend(reviewers)
        
        # Create PR
        pr_result = subprocess.run(
            args,
            check=True,
            capture_output=True,
            text=True
        )
        
        # æå–PRé“¾æ¥
        pr_url = pr_result.stdout.strip()
        if pr_url:
            logger.info(f"âœ… Successfully created PR for tag {argsInfo.projectTag}")
            logger.info(f"ğŸ”— PRé“¾æ¥: {pr_url}")
            print(f"\nğŸš€ PRå·²åˆ›å»º! è¯·æŸ¥çœ‹: {pr_url}\n")
        else:
            logger.info(f"Successfully created PR for tag {argsInfo.projectTag}")
        
        logger.debug(f"PR creation output: {pr_result.stdout}")
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to create tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in createTagPR: {str(e)}")
        raise

def mergePR():
    try:
        merge_result = subprocess.run(
            ["gh", "pr", "merge", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "-r", f"{argsInfo.githubID}:dev-changelog"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("âœ… Successfully merged PR")
        
        # è·å–PRé“¾æ¥ä¿¡æ¯
        try:
            pr_info = subprocess.run(
                ["gh", "pr", "view", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", f"{argsInfo.githubID}:dev-changelog", "--json", "url"],
                capture_output=True,
                text=True
            )
            if pr_info.returncode == 0:
                import json
                pr_data = json.loads(pr_info.stdout)
                pr_url = pr_data.get('url', '')
                if pr_url:
                    logger.info(f"ğŸ”— å·²åˆå¹¶çš„PR: {pr_url}")
                    print(f"\nğŸ‰ PRå·²æˆåŠŸåˆå¹¶! PRé“¾æ¥: {pr_url}\n")
        except:
            pass  # å¦‚æœè·å–å¤±è´¥ï¼Œä¸å½±å“ä¸»æµç¨‹
            
        logger.debug(f"Merge output: {merge_result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to merge PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in mergePR: {str(e)}")
        raise

def runRelease():
    """æ‰§è¡ŒGitHub Auto Release workflow"""
    try:
        # æ£€æŸ¥ghå‘½ä»¤æ˜¯å¦å¯ç”¨
        gh_check = subprocess.run(
            ["gh", "--version"],
            capture_output=True,
            text=True
        )
        if gh_check.returncode != 0:
            logger.error("GitHub CLI (gh) is not installed or not available")
            logger.error("Please install GitHub CLI: https://cli.github.com/")
            raise SystemExit(1)

        # æ£€æŸ¥æ˜¯å¦å·²ç™»å½•GitHub
        auth_check = subprocess.run(
            ["gh", "auth", "status"],
            capture_output=True,
            text=True
        )
        if auth_check.returncode != 0:
            logger.error("Not logged in to GitHub")
            logger.error("Please run: gh auth login")
            raise SystemExit(1)

        # è®¾ç½®é»˜è®¤ä»“åº“
        repo_name = f"{argsInfo.projectOrg}/{argsInfo.projectName}"
        logger.info(f"Setting default repository to {repo_name}")

        set_default_result = subprocess.run(
            ["gh", "repo", "set-default", repo_name],
            capture_output=True,
            text=True
        )
        if set_default_result.returncode != 0:
            logger.warning(f"Could not set default repository: {set_default_result.stderr}")
            logger.info("Continuing with explicit repository specification...")

        # è§¦å‘Auto Release workflow
        logger.info(f"Triggering 'Auto Release' workflow for {repo_name}")

        workflow_cmd = ["gh", "workflow", "run", "Auto Release"]
        if set_default_result.returncode != 0:
            workflow_cmd.extend(["--repo", repo_name])

        workflow_result = subprocess.run(
            workflow_cmd,
            capture_output=True,
            text=True
        )

        if workflow_result.returncode == 0:
            logger.info("âœ… Successfully triggered 'Auto Release' workflow")
            logger.info("ğŸš€ The workflow will automatically create tags and PRs")
            print(f"\nğŸ‰ Auto Release workflow triggered for {repo_name}!")
            print("ğŸ“‹ You can check the workflow status at:")
            print(f"   https://github.com/{repo_name}/actions")
        else:
            logger.error(f"Failed to trigger 'Auto Release' workflow: {workflow_result.stderr}")
            if "could not find workflow" in workflow_result.stderr.lower():
                logger.error("Make sure the 'Auto Release' workflow exists in the repository")
                logger.error("Check: https://github.com/{}/actions".format(repo_name))
            raise SystemExit(1)

    except subprocess.CalledProcessError as e:
        logger.error(f"Command execution failed: {e}")
        logger.error(f"Error output: {e.stderr}")
        raise SystemExit(1)
    except Exception as e:
        logger.error(f"Unexpected error in runRelease: {str(e)}")
        raise SystemExit(1)

def searchProjects():
    """æœç´¢GitHubç»„ç»‡ä¸‹çš„é¡¹ç›®ï¼Œæ”¯æŒæ¨¡ç³Šæœç´¢å¹¶æŒ‰æ›´æ–°æ—¶é—´æ’åº"""
    try:
        # æ„å»ºghå‘½ä»¤
        org = argsInfo.projectOrg
        search_query = argsInfo.projectName
        
        if search_query:
            # ä½¿ç”¨ghå‘½ä»¤è¿›è¡Œæœç´¢ï¼ŒæŒ‰pushedAtæ’åºï¼Œè¿‡æ»¤åŒ…å«æœç´¢å…³é”®è¯çš„é¡¹ç›®
            jq_filter = f'.[] | select(.name | test("{search_query}"; "i")) | {{name: .name, pushedAt: .pushedAt, url: .url}}'
        else:
            # è·å–æ‰€æœ‰ä»“åº“
            jq_filter = '.[] | {name: .name, pushedAt: .pushedAt, url: .url}'

        # æ„å»ºghå‘½ä»¤
        gh_cmd = [
            "gh", "repo", "list", org,
            "--limit", "100",
            "--json", "name,pushedAt,url",
            "--jq", jq_filter
        ]
        
        # æ‰§è¡Œghå‘½ä»¤
        result = subprocess.run(
            gh_cmd,
            capture_output=True,
            text=True,
            check=True
        )
        
        # è§£æè¾“å‡º
        repos = []
        for line in result.stdout.strip().split('\n'):
            if line.strip():
                try:
                    repo_data = json.loads(line)
                    repos.append(repo_data)
                except json.JSONDecodeError:
                    continue
        
        if not repos:
            return
        
        # æŒ‰æ›´æ–°æ—¶é—´æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰ï¼‰
        repos.sort(key=lambda x: x['pushedAt'], reverse=True)
        
        # ç›´æ¥è¾“å‡ºç»“æœï¼Œä¸æ˜¾ç¤ºæ€»ç»“ä¿¡æ¯
        for repo in repos:
            name = repo['name']
            
            if argsInfo.quiet:
                # é™é»˜æ¨¡å¼ï¼Œåªè¾“å‡ºé¡¹ç›®åç§°
                print(name)
            else:
                # æ­£å¸¸æ¨¡å¼ï¼Œè¾“å‡ºæ—¶é—´å’Œé¡¹ç›®åç§°
                pushed_at = repo['pushedAt']
                # æ ¼å¼åŒ–æ—¥æœŸ
                try:
                    from datetime import datetime
                    # è§£æUTCæ—¶é—´å¹¶è½¬æ¢ä¸ºæœ¬åœ°æ—¶é—´
                    dt = datetime.fromisoformat(pushed_at.replace('Z', '+00:00'))
                    # è½¬æ¢ä¸ºæœ¬åœ°æ—¶é—´
                    local_dt = dt.astimezone()
                    formatted_date = local_dt.strftime('%Y-%m-%d %H:%M')
                except:
                    formatted_date = pushed_at[:16].replace('T', ' ')
                
                print(f"{formatted_date:<20} {name:<20} {repo['url']}")
        
    except subprocess.CalledProcessError as e:
        if "authentication required" in e.stderr.lower() or "not logged in" in e.stderr.lower():
            logger.error("Not logged in to GitHub")
            logger.error("Please run: gh auth login")
        elif "organization not found" in e.stderr.lower():
            logger.error(f"Organization '{org}' not found or not accessible")
        else:
            logger.error(f"GitHub CLI error: {e.stderr}")
        raise SystemExit(1)
    except Exception as e:
        logger.error(f"Unexpected error in searchProjects: {str(e)}")
        raise SystemExit(1)

def createOrUpdateRepo():
    dir = os.path.expanduser(argsInfo.projectRootDir)
    if not os.path.exists(dir):
        os.makedirs(dir)

    logger.info(f"Tagging project: {dir}, {argsInfo.projectName}")
    os.chdir(dir)

    if not os.path.exists(dir + "/" + argsInfo.projectName):
        createRepo()
        os.chdir(argsInfo.projectName)
        initRepo()
    else:
        os.chdir(argsInfo.projectName)

def main(argv):
    parser = argparse.ArgumentParser(description='Pack for CRP.')
    parser.add_argument('command', nargs='?', default='tag', choices=['tag', 'merge', 'test', 'lasttag', 'release', 'projects'], help='The command type (list or pack)')

    parser.add_argument('--dir', type=str, default=None, help='The project directory')
    parser.add_argument('--org', type=str, default=None, help='The project organization, e.g: linuxdeepin')
    parser.add_argument('--name', type=str, default=None, help='The project name')
    parser.add_argument('--branch', type=str, default=None, help='The project branch')
    parser.add_argument('--tag', type=str, default=None, help='The project tag')
    parser.add_argument('--reviewer', type=str, default=[], nargs='+', help='The project reviewers')
    parser.add_argument('--verbose', action='store_true', help='Show verbose output for git operations')
    parser.add_argument('--quiet', action='store_true', help='Show brief output results')

    if "DEBEMAIL" not in os.environ:
        os.environ["DEBEMAIL"] = argsInfo.debEmail

    args = parser.parse_args()

    if (args.name is not None):
        argsInfo.projectName = args.name
    elif (args.command == 'projects'):
        # projectså‘½ä»¤å¦‚æœæ²¡æœ‰æä¾›nameå‚æ•°ï¼Œåˆ™æ¸…ç©ºæœç´¢å…³é”®è¯
        argsInfo.projectName = ""
    if (args.branch is not None):
        argsInfo.projectBranch = args.branch
    if (args.tag is not None):
        argsInfo.projectTag = args.tag
    else:
        argsInfo.autoGeneratedProjectTag = True
    if (args.dir is not None):
        argsInfo.projectRootDir = args.dir
    if (args.org is not None):
        argsInfo.projectOrg = args.org
    reviewers = args.reviewer
    if len(reviewers) > 0:
        argsInfo.projectReviewers = reviewers
    argsInfo.verbose = args.verbose
    argsInfo.quiet = args.quiet

    if (args.command == 'release'):
        # releaseå‘½ä»¤ä¸éœ€è¦createOrUpdateRepoï¼Œç›´æ¥æ‰§è¡Œ
        runRelease()
    elif (args.command == 'projects'):
        # projectså‘½ä»¤ä¸éœ€è¦createOrUpdateRepoï¼Œç›´æ¥æœç´¢é¡¹ç›®
        searchProjects()
    else:
        createOrUpdateRepo()
        if (args.command == 'merge'):
            mergePR()
        elif (args.command == 'test'):
            initTagPR()
            try:
                diff_result = subprocess.run(
                    "git diff HEAD^ HEAD | cat",
                    shell=True,
                    check=True,
                    capture_output=True,
                    text=True
                )
                print(diff_result.stdout)
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to show diff: {e.stderr}")
        elif (args.command == 'lasttag'):
            lastTag = fetchLastTag()
            logger.info(f"Last Tag: {lastTag}")
        else:
            initTagPR()
            createTagPR()

if(__name__=="__main__"):
    main(sys.argv)
