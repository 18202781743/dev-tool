import sys
import argparse
import subprocess
import re
import os
import yaml
from git import Repo
import time

class Const:
    TAGREMOTENAME = 'dev-changelog'
    TAGREMOTEURLPREFIX = 'https://github.com/'

class Repository:
    def __init__(self, name, branch, targetTag, distribution, versionLastSplit, enable):
        self.name = name
        self.branch = branch
        self.targetTag = targetTag
        self.distribution = distribution
        self.enable = enable
        self.versionLastSplit = versionLastSplit
    def __str__(self):
        return f"Repository(name={self.name}, branch={self.branch}, targetTag={self.targetTag}, distribution={self.distribution}, versionLastSplit={self.versionLastSplit}, enable={self.enable})"

# 全局参数
class ArgsInfo:
    projectName = "xxxtools" # 项目名称
    projectBranch = "master" # 项目分支
    projectTag = "1.0.0" # 自定义tag
    githubID = "xxxx"     # github 用户id
    debEmail = "xxxx"
    autoGeneratedProjectTag = False # tag是否自动生成
    projectOrg = "linuxdeepin"
    projectReviewers = []

    projectRootDir = "~/.cache/git-tag-dir" # 打tag项目根目录
    configPath= "git-tag.yaml"
    reps = []
    mantainer = ""

argsInfo = ArgsInfo()

def cloneRepo(org, repoName):
    a = subprocess.call(["git", "clone", Const.TAGREMOTEURLPREFIX + org + "/" + repoName], shell=False)

def initRepo(org, repoName):
    # 新增remote
    remoteUrl = Const.TAGREMOTEURLPREFIX + org + "/" + repoName
    # TODO 检查是否已经有remote了
    subprocess.run(["git", "remote", "add", Const.TAGREMOTENAME, remoteUrl], shell=False)
    subprocess.call(["gh", "repo", "set-default", org + "/" + repoName], shell=False)
    
def fetchLastTag():
    a = subprocess.call("git fetch origin", shell=True)
    lastTag = subprocess.check_output("git describe --tags --abbrev=0", shell=True)
    lastTag = lastTag.decode().replace('\n', '')
    return lastTag

def createTag(rep):
    # 保存当前工作区
    stashLastCount = len(subprocess.run(["git", "stash", "list"], stdout=subprocess.PIPE).stdout.decode('utf-8').splitlines())
    subprocess.call(["git", "stash"], shell=False)
    stashCount = len(subprocess.run(["git", "stash", "list"], stdout=subprocess.PIPE).stdout.decode('utf-8').splitlines())

    stashSuc = stashCount == stashLastCount
    if not stashSuc:
        print("stash failed")

    # fetch
    subprocess.call(["git", "fetch", Const.TAGREMOTENAME], shell=False)
    # checkout branch
    subprocess.call(["git", "checkout", Const.TAGREMOTENAME + "/" + rep.branch], shell=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # 生成git log TODO
    gitlogLines = subprocess.run(["git", "log", "--pretty=format:'%s'"], stdout=subprocess.PIPE).stdout.decode('utf-8').splitlines()
    printLogList = gitlogLines[:min(30, len(gitlogLines))]
    for i, item in enumerate(printLogList):
        print(f"{i + 1}: {item}")
    index = int(input(f"({rep.name})请输入log截取到的位置: "))
    logList = gitlogLines[:index]

    # 上一次的TAG
    try:
        # 获取当前版本
        current_version = subprocess.check_output(
            ["dpkg-parsechangelog", "-S", "Version"],
            text=True
        ).strip()

        current_distribution = subprocess.check_output(
            ["dpkg-parsechangelog", "-S", "Distribution"],
            text=True
        ).strip()

        current_maintainer = subprocess.check_output(
            ["dpkg-parsechangelog", "-S", "Maintainer"],
            text=True
        ).strip()

        nextVersion = ""
        nextDistribution = ""
        nextMaintainer = ""

        if rep.distribution == None:
            nextDistribution = current_distribution
        else:
            nextDistribution = rep.distribution
        
        if rep.versionLastSplit == None:
            rep.versionLastSplit = "."

        if rep.targetTag == None:
            # 生成下一版本（仅递增 Debian 修订号）
            lastSplit = current_version.split(rep.versionLastSplit)[-1]
            newLastSplit = str(int(lastSplit) + 1)
            newVersion = '.'.join(current_version.split('.')[:-1]) + '.' + newLastSplit
            nextVersion = newVersion
        else:
            nextVersion = rep.targetTag

        if argsInfo.mantainer == None:
            nextMaintainer = current_maintainer
        else:
            nextMaintainer = argsInfo.mantainer
        
        os.environ['DEBEMAIL'] = nextMaintainer
        # 执行 dch 更新
        subprocess.run([
            "dch",
            "-v", nextVersion,
            "-D", nextDistribution,
            "release to " + nextVersion
        ], check=True)

        for log in logList:
            subprocess.run([
                "dch",
                "-a", log
            ], check=True)
        
        print(f"Successfully updated to version: {nextVersion}")
        
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {e}")
    except Exception as e:
        print(f"Error: {str(e)}")

    a = subprocess.call(["git", "commit", "-a", "-m", "chore: bump version to " + nextVersion + "\n\n" + "update changelog to " + nextVersion], shell=False)

def createTagPR():
    a = subprocess.call(["git", "push", Const.TAGREMOTENAME, Const.TAGREMOTENAME, "-f"], shell=True)
    a = subprocess.call(["gh", "pr", "create", "--title", "chore: bump version to " + argsInfo.projectTag,  "--body", "update changelog to " + argsInfo.projectTag], shell=False)

def mergePR():
    a = subprocess.call(["gh", "pr", "merge", "-r", argsInfo.githubID + ":" + "dev-changelog"], shell=False)

def createOrUpdateRepo(rep):
    dir = os.path.expanduser(argsInfo.projectRootDir)
    if not os.path.exists(dir):
        os.makedirs(dir)
    
    os.chdir(dir)

    org = rep.name.split("/")[0]
    repoName = rep.name.split("/")[1]
    print("current dir: " + os.getcwd(), dir + "/" + rep.name)

    if not os.path.exists(dir + "/" + repoName):
        cloneRepo(org, repoName)
        os.chdir(repoName)
        initRepo(org, repoName)
    else:
        os.chdir(repoName)
        initRepo(org, repoName)

def handleReps():
    for rep in argsInfo.reps:
        print("\n====================================================")
        print("开始处理: ", rep.name)
        print("====================================================\n")
        if rep.enable == False:
            print("跳过: ", rep.name)
            continue
        time.sleep(1)
        createOrUpdateRepo(rep)
        createTag(rep)
        createTagPR()
        # mergePR()
        # os.chdir("..")

def parseConfig():
    with open(argsInfo.configPath, 'r') as f:
        config = yaml.safe_load(f)
        for repo in config['repositories']:
            argsInfo.reps.append(Repository(repo.get('name'), repo.get('branch'), repo.get('targetTag'), repo.get('distribution'), repo.get('versionLastSplit'), repo.get('enable')))
        
        argsInfo.mantainer = config["extra"].get("maintainer")

def main(argv):
    parser = argparse.ArgumentParser(description='Pack for CRP.')
    parser.add_argument('command', nargs='?', default='tag', choices=['tag', 'merge', 'test', 'lasttag'], help='The command type (list or pack)')

    parser.add_argument('--dir', type=str, default=None, help='The project directory')
    parser.add_argument('--org', type=str, default=None, help='The project organization, e.g: linuxdeepin')
    parser.add_argument('--name', type=str, default=None, help='The project name')
    parser.add_argument('--branch', type=str, default=None, help='The project branch')
    parser.add_argument('--tag', type=str, default=None, help='The project tag')
    parser.add_argument('--config', type=str, default=None, help='The project config file')

    args = parser.parse_args()

    if (args.name is not None):
        argsInfo.projectName = args.name
    if (args.branch is not None):
        argsInfo.projectBranch = args.branch
    if (args.tag is not None):
        argsInfo.projectTag = args.tag
    else:
        argsInfo.autoGeneratedProjectTag = True
    if (args.dir is not None):
        argsInfo.projectRootDir = args.dir
    if (args.org is not None):
        argsInfo.projectOrg = args.org
    if (args.config is not None):
        argsInfo.configPath = args.config

    parseConfig()
    handleReps()

    # createOrUpdateRepo()
    # if (args.command == 'merge'):
    #     mergePR()
    # elif (args.command == 'test'):
    #     initTagPR()
    #     subprocess.call("git diff HEAD^ HEAD | cat", shell=True)
    # elif (args.command == 'lasttag'):
    #     lastTag = fetchLastTag()
    #     print("Last Tag:", lastTag)
    # else:
    #     initTagPR()
    #     createTagPR()

if(__name__=="__main__"):
    main(sys.argv)


# git-tag --projects 