import sys
import argparse
import subprocess
import re
import os
import logging
import json
from datetime import datetime

class Colors:
    RESET = '\033[0m'
    RED = '\033[31m'      # é”™è¯¯
    YELLOW = '\033[33m'   # è­¦å‘Š
    GREEN = '\033[32m'    # æˆåŠŸä¿¡æ¯
    GRAY = '\033[90m'     # è°ƒè¯•ä¿¡æ¯

class ColoredFormatter(logging.Formatter):
    COLORS = {
        logging.ERROR: Colors.RED,
        logging.WARNING: Colors.YELLOW,
        logging.INFO: Colors.GREEN,
        logging.DEBUG: Colors.GRAY,
    }

    def format(self, record):
        # å…ˆæ ¼å¼åŒ–æ¶ˆæ¯
        formatted = super().format(record)
        
        # åªåœ¨ç»ˆç«¯ä¸­æ˜¾ç¤ºé¢œè‰²ï¼Œæ•´è¡Œåº”ç”¨é¢œè‰²
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            color = self.COLORS.get(record.levelno, '')
            if color:
                formatted = f"{color}{formatted}{Colors.RESET}"
        
        return formatted

# å…¨å±€å‚æ•°
class ArgsInfo:
    def __init__(self):
        # é»˜è®¤å€¼
        self.projectName = "xxxtools" # é¡¹ç›®åç§°
        self.projectBranch = "master" # é¡¹ç›®åˆ†æ”¯
        self.projectTag = "1.0.0" # è‡ªå®šä¹‰tag
        self.autoGeneratedProjectTag = False # tagæ˜¯å¦è‡ªåŠ¨ç”Ÿæˆ
        self.projectOrg = "linuxdeepin"
        self.projectReviewers = []
        self.verbose = False # æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†è¾“å‡º
        # ä»Žé…ç½®æ–‡ä»¶è¯»å–å‚æ•°
        self.projectRootDir = "~/.cache/git-tag-dir" # é»˜è®¤å€¼
        config_path = os.path.expanduser('~/.config/dev-tool/git-tag-config.json')
        with open(config_path) as f:
            config = json.load(f)
        
        # Gitä¿¡æ¯
        self.githubID = config['git']['githubID']     # github ç”¨æˆ·id
        self.debEmail = config['git']['debEmail']     # debian æ‰“åŒ…é‚®ç®±

        # ä»Žé…ç½®æ–‡ä»¶ä¸­è¯»å–å…¶ä»–å‚æ•°ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰
        if 'params' in config:
            params = config['params']
            self.projectBranch = params.get('projectBranch', self.projectBranch)
            self.projectOrg = params.get('projectOrg', self.projectOrg)
            self.projectReviewers = params.get('projectReviewers', self.projectReviewers)
            self.projectRootDir = params.get('projectRootDir', self.projectRootDir)

argsInfo = ArgsInfo()

def setup_logging():
    level = logging.DEBUG if argsInfo.verbose else logging.INFO
    
    # åˆ›å»ºlogger
    logger = logging.getLogger(__name__)
    logger.setLevel(level)
    
    # é¿å…é‡å¤æ·»åŠ handler
    if logger.handlers:
        logger.handlers.clear()
    
    # åˆ›å»ºæŽ§åˆ¶å°å¤„ç†å™¨
    handler = logging.StreamHandler()
    handler.setLevel(level)
    
    # ä½¿ç”¨å½©è‰²æ ¼å¼åŒ–å™¨
    formatter = ColoredFormatter(
        fmt='[%(asctime)s] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger

def find_config_file(filename):
    """æŸ¥æ‰¾é…ç½®æ–‡ä»¶ï¼Œå…ˆåœ¨å½“å‰ç›®å½•æŸ¥æ‰¾ï¼Œç„¶åŽåœ¨~/.config/dev-tool/packagesæŸ¥æ‰¾"""
    # æ£€æŸ¥å½“å‰ç›®å½•
    local_path = os.path.join(os.getcwd(), filename)
    if os.path.exists(local_path):
        return local_path
    
    # æ£€æŸ¥packagesç›®å½•
    packages_path = os.path.expanduser(f'~/.config/dev-tool/packages/{filename}')
    if os.path.exists(packages_path):
        return packages_path
    
    # æ£€æŸ¥é»˜è®¤configç›®å½•
    config_path = os.path.expanduser(f'~/.config/dev-tool/{filename}')
    if os.path.exists(config_path):
        return config_path
    
    raise FileNotFoundError(f"Could not find config file {filename} in any of: current directory, ~/.config/dev-tool/packages/, ~/.config/dev-tool/")

logger = setup_logging()

def createRepo():
    try:
        result = subprocess.run(
            ["git", "clone", "https://github.com/" + argsInfo.projectOrg + "/" + argsInfo.projectName + ".git"],
            check=True,
            capture_output=not argsInfo.verbose,
            text=True
        )
        logger.info(f"Successfully cloned repository: {argsInfo.projectOrg}/{argsInfo.projectName}")
        if not argsInfo.verbose:
            logger.debug(f"Clone output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to clone repository {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.error(f"Error: {e.stderr}")
        raise

def initRepo():
    try:
        # Add github remote
        result = subprocess.run(
            f"git remote add github https://github.com/{argsInfo.githubID}/{argsInfo.projectName}.git",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("Successfully added github remote")
        logger.debug(f"Add remote output: {result.stdout}")

        # Set default repo
        result = subprocess.run(
            ["gh", "repo", "set-default", f"{argsInfo.projectOrg}/{argsInfo.projectName}"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info(f"Successfully set default repository to {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.debug(f"Set default repo output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize repository: {e.stderr}")
        raise
    
def fetchLastTag():
    try:
        # Fetch from origin
        fetch_result = subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Fetch output: {fetch_result.stdout}")

        # Get last tag
        tag_result = subprocess.run(
            "git describe --tags --abbrev=0",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        lastTag = tag_result.stdout.strip()
        logger.info(f"Found last tag: {lastTag}")
        return lastTag
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to fetch/get last tag: {e.stderr}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in fetchLastTag: {str(e)}")
        return None

def autoGeneratedTagByLastTag(lastTag):
    increment_part = 'patch'  # é»˜è®¤é€’å¢žéƒ¨åˆ†ä¸º 'patch' {major}.{minor}.{patch}
    parts = lastTag.split('.')
    if len(parts) != 3:
        raise ValueError(f"æ— æ•ˆçš„ç‰ˆæœ¬å·æ ¼å¼ '{lastTag}'ï¼Œåº”ä¸º major.minor.patch")

    try:
        major = int(parts[0])
        minor = int(parts[1])
        patch = int(parts[2])
    except ValueError:
        raise ValueError(f"ç‰ˆæœ¬å·å„éƒ¨åˆ†å¿…é¡»ä¸ºæ•´æ•° '{lastTag}'")
        
    if increment_part == 'patch':
        patch += 1
    elif increment_part == 'minor':
        minor += 1
        patch = 0
    elif increment_part == 'major':
        major += 1
        minor = 0
        patch = 0
    else:
        raise ValueError(f"æ— æ•ˆçš„é€’å¢žéƒ¨åˆ† '{increment_part}'ï¼Œåº”ä¸º 'major', 'minor', æˆ– 'patch'")

    return f"{major}.{minor}.{patch}"

def initTagPR():
    try:
        # Git operations
        subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            ["git", "reset", "--hard", f"origin/{argsInfo.projectBranch}"],
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            f"git checkout -B dev-changelog origin/{argsInfo.projectBranch}",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Set DEBEMAIL environment variable
        os.environ["DEBEMAIL"] = argsInfo.debEmail

        lastTag = fetchLastTag()
        logger.info(f"Last Tag: {lastTag}")

        if argsInfo.autoGeneratedProjectTag:
            argsInfo.projectTag = autoGeneratedTagByLastTag(lastTag)
        
        logger.info(f"Project Tag: {argsInfo.projectTag}")

        # Get commit info
        commit_result = subprocess.run(
            ["git", "log", "--pretty=format:%s", "--no-merges", f"{lastTag}..HEAD"],
            check=True,
            capture_output=True,
            text=True
        )
        commitInfo = commit_result.stdout
        if not commitInfo:
            commitInfo = f"Release {argsInfo.projectTag}"

        logger.info(f"Changelog Info: {commitInfo}")

        # Process changelog
        with subprocess.Popen(
            ["xargs", "-d", "\n", "-I", "{}", "dch", "-v", argsInfo.projectTag, "{}"],
            stdin=subprocess.PIPE,
            text=True
        ) as dch_process:
            dch_process.communicate(input=commitInfo)

        subprocess.run(
            "dch -r ''",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Commit changes
        subprocess.run(
            ["git", "commit", "-a", "-m", f"chore: bump version to {argsInfo.projectTag}\n\nupdate changelog to {argsInfo.projectTag}"],
            check=True,
            capture_output=True,
            text=True
        )

    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in initTagPR: {str(e)}")
        raise

def createTagPR():
    try:
        # Check if forked repo exists
        fork_check = subprocess.run(
            ["gh", "repo", "view", f"{argsInfo.githubID}/{argsInfo.projectName}"],
            capture_output=True,
            text=True
        )
        
        if fork_check.returncode != 0:
            # Fork the repo if not exists
            logger.info(f"Forking repository {argsInfo.projectOrg}/{argsInfo.projectName}")
            fork_result = subprocess.run(
                ["gh", "repo", "fork", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "--clone=false"],
                check=True,
                capture_output=True,
                text=True
            )
            logger.debug(f"Fork output: {fork_result.stdout}")

        # Push to github
        push_result = subprocess.run(
            "git push github dev-changelog -f",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Push output: {push_result.stdout}")

        # Prepare PR creation command
        args = [
            "gh", "pr", "create",
            "--title", f"chore: bump version to {argsInfo.projectTag}",
            "--body", f"update changelog to {argsInfo.projectTag}"
        ]
        
        # Add reviewers if specified
        if argsInfo.projectReviewers:
            reviewers = []
            for value in argsInfo.projectReviewers:
                reviewers.extend(['--reviewer', value])
            args.extend(reviewers)
        
        # Create PR
        pr_result = subprocess.run(
            args,
            check=True,
            capture_output=True,
            text=True
        )
        
        # æå–PRé“¾æŽ¥
        pr_url = pr_result.stdout.strip()
        if pr_url:
            logger.info(f"âœ… Successfully created PR for tag {argsInfo.projectTag}")
            logger.info(f"ðŸ”— PRé“¾æŽ¥: {pr_url}")
            print(f"\nðŸš€ PRå·²åˆ›å»º! è¯·æŸ¥çœ‹: {pr_url}\n")
        else:
            logger.info(f"Successfully created PR for tag {argsInfo.projectTag}")
        
        logger.debug(f"PR creation output: {pr_result.stdout}")
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to create tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in createTagPR: {str(e)}")
        raise

def mergePR():
    try:
        merge_result = subprocess.run(
            ["gh", "pr", "merge", "-r", f"{argsInfo.githubID}:dev-changelog"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("âœ… Successfully merged PR")
        
        # èŽ·å–PRé“¾æŽ¥ä¿¡æ¯
        try:
            pr_info = subprocess.run(
                ["gh", "pr", "view", f"{argsInfo.githubID}:dev-changelog", "--json", "url"],
                capture_output=True,
                text=True
            )
            if pr_info.returncode == 0:
                import json
                pr_data = json.loads(pr_info.stdout)
                pr_url = pr_data.get('url', '')
                if pr_url:
                    logger.info(f"ðŸ”— å·²åˆå¹¶çš„PR: {pr_url}")
                    print(f"\nðŸŽ‰ PRå·²æˆåŠŸåˆå¹¶! PRé“¾æŽ¥: {pr_url}\n")
        except:
            pass  # å¦‚æžœèŽ·å–å¤±è´¥ï¼Œä¸å½±å“ä¸»æµç¨‹
            
        logger.debug(f"Merge output: {merge_result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to merge PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in mergePR: {str(e)}")
        raise

def createOrUpdateRepo():
    dir = os.path.expanduser(argsInfo.projectRootDir)
    if not os.path.exists(dir):
        os.makedirs(dir)
    
    logger.info(f"Tagging project: {dir}, {argsInfo.projectName}")
    os.chdir(dir)

    if not os.path.exists(dir + "/" + argsInfo.projectName):
        createRepo()
        os.chdir(argsInfo.projectName)
        initRepo()
    else:
        os.chdir(argsInfo.projectName)

def main(argv):
    parser = argparse.ArgumentParser(description='Pack for CRP.')
    parser.add_argument('command', nargs='?', default='tag', choices=['tag', 'merge', 'test', 'lasttag'], help='The command type (list or pack)')

    parser.add_argument('--dir', type=str, default=None, help='The project directory')
    parser.add_argument('--org', type=str, default=None, help='The project organization, e.g: linuxdeepin')
    parser.add_argument('--name', type=str, default=None, help='The project name')
    parser.add_argument('--branch', type=str, default=None, help='The project branch')
    parser.add_argument('--tag', type=str, default=None, help='The project tag')
    parser.add_argument('--reviewer', type=str, default=[], nargs='+', help='The project reviewers')
    parser.add_argument('--verbose', action='store_true', help='Show verbose output for git operations')

    if "DEBEMAIL" not in os.environ:
        os.environ["DEBEMAIL"] = argsInfo.debEmail

    args = parser.parse_args()

    if (args.name is not None):
        argsInfo.projectName = args.name
    if (args.branch is not None):
        argsInfo.projectBranch = args.branch
    if (args.tag is not None):
        argsInfo.projectTag = args.tag
    else:
        argsInfo.autoGeneratedProjectTag = True
    if (args.dir is not None):
        argsInfo.projectRootDir = args.dir
    if (args.org is not None):
        argsInfo.projectOrg = args.org
    reviewers = args.reviewer
    if len(reviewers) > 0:
        argsInfo.projectReviewers = reviewers
    argsInfo.verbose = args.verbose

    createOrUpdateRepo()
    if (args.command == 'merge'):
        mergePR()
    elif (args.command == 'test'):
        initTagPR()
        try:
            diff_result = subprocess.run(
                "git diff HEAD^ HEAD | cat",
                shell=True,
                check=True,
                capture_output=True,
                text=True
            )
            print(diff_result.stdout)
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to show diff: {e.stderr}")
    elif (args.command == 'lasttag'):
        lastTag = fetchLastTag()
        logger.info(f"Last Tag: {lastTag}")
    else:
        initTagPR()
        createTagPR()

if(__name__=="__main__"):
    main(sys.argv)
