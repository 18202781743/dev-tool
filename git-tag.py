import sys
import argparse
import subprocess
import re
import os
import logging
import json
from datetime import datetime

class Colors:
    RESET = '\033[0m'
    RED = '\033[31m'      # 错误
    YELLOW = '\033[33m'   # 警告
    GREEN = '\033[32m'    # 成功信息
    GRAY = '\033[90m'     # 调试信息

class ColoredFormatter(logging.Formatter):
    COLORS = {
        logging.ERROR: Colors.RED,
        logging.WARNING: Colors.YELLOW,
        logging.INFO: Colors.GREEN,
        logging.DEBUG: Colors.GRAY,
    }

    def format(self, record):
        # 先格式化消息
        formatted = super().format(record)
        
        # 只在终端中显示颜色，整行应用颜色
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            color = self.COLORS.get(record.levelno, '')
            if color:
                formatted = f"{color}{formatted}{Colors.RESET}"
        
        return formatted

# 全局参数
class ArgsInfo:
    def __init__(self):
        # 默认值
        self.projectName = "xxxtools" # 项目名称
        self.projectBranch = "master" # 项目分支
        self.projectTag = "1.0.0" # 自定义tag
        self.autoGeneratedProjectTag = False # tag是否自动生成
        self.projectOrg = "linuxdeepin"
        self.projectReviewers = []
        self.verbose = False # 是否显示详细输出
        self.quiet = False # 是否静默模式（不显示时间戳）
        # 从配置文件读取参数
        self.projectRootDir = "~/.cache/git-tag-dir" # 默认值
        config_path = os.path.expanduser('~/.config/dev-tool/git-tag-config.json')
        with open(config_path) as f:
            config = json.load(f)
        
        # Git信息
        self.githubID = config['git']['githubID']     # github 用户id
        self.debEmail = config['git']['debEmail']     # debian 打包邮箱

        # 从配置文件中读取其他参数（如果存在）
        if 'params' in config:
            params = config['params']
            self.projectBranch = params.get('projectBranch', self.projectBranch)
            self.projectOrg = params.get('projectOrg', self.projectOrg)
            self.projectReviewers = params.get('projectReviewers', self.projectReviewers)
            self.projectRootDir = params.get('projectRootDir', self.projectRootDir)

argsInfo = ArgsInfo()

def setup_logging():
    level = logging.DEBUG if argsInfo.verbose else logging.INFO
    
    # 创建logger
    logger = logging.getLogger(__name__)
    logger.setLevel(level)
    
    # 避免重复添加handler
    if logger.handlers:
        logger.handlers.clear()
    
    # 创建控制台处理器
    handler = logging.StreamHandler()
    handler.setLevel(level)
    
    # 使用彩色格式化器
    formatter = ColoredFormatter(
        fmt='[%(asctime)s] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger

def find_config_file(filename):
    """查找配置文件，先在当前目录查找，然后在~/.config/dev-tool/packages查找"""
    # 检查当前目录
    local_path = os.path.join(os.getcwd(), filename)
    if os.path.exists(local_path):
        return local_path
    
    # 检查packages目录
    packages_path = os.path.expanduser(f'~/.config/dev-tool/packages/{filename}')
    if os.path.exists(packages_path):
        return packages_path
    
    # 检查默认config目录
    config_path = os.path.expanduser(f'~/.config/dev-tool/{filename}')
    if os.path.exists(config_path):
        return config_path
    
    raise FileNotFoundError(f"Could not find config file {filename} in any of: current directory, ~/.config/dev-tool/packages/, ~/.config/dev-tool/")

logger = setup_logging()

def createRepo():
    try:
        result = subprocess.run(
            ["git", "clone", "https://github.com/" + argsInfo.projectOrg + "/" + argsInfo.projectName + ".git"],
            check=True,
            capture_output=not argsInfo.verbose,
            text=True
        )
        logger.info(f"Successfully cloned repository: {argsInfo.projectOrg}/{argsInfo.projectName}")
        if not argsInfo.verbose:
            logger.debug(f"Clone output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to clone repository {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.error(f"Error: {e.stderr}")
        raise

def initRepo():
    try:
        # Add github remote
        result = subprocess.run(
            f"git remote add github https://github.com/{argsInfo.githubID}/{argsInfo.projectName}.git",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("Successfully added github remote")
        logger.debug(f"Add remote output: {result.stdout}")

        # Set default repo
        result = subprocess.run(
            ["gh", "repo", "set-default", f"{argsInfo.projectOrg}/{argsInfo.projectName}"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info(f"Successfully set default repository to {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.debug(f"Set default repo output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize repository: {e.stderr}")
        raise
    
def fetchLastTag():
    try:
        # Fetch from origin
        fetch_result = subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Fetch output: {fetch_result.stdout}")

        # Get last tag
        tag_result = subprocess.run(
            "git describe --tags --abbrev=0",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        lastTag = tag_result.stdout.strip()
        logger.info(f"Found last tag: {lastTag}")
        return lastTag
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to fetch/get last tag: {e.stderr}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in fetchLastTag: {str(e)}")
        return None

def autoGeneratedTagByLastTag(lastTag):
    increment_part = 'patch'  # 默认递增部分为 'patch' {major}.{minor}.{patch}
    parts = lastTag.split('.')
    if len(parts) != 3:
        raise ValueError(f"无效的版本号格式 '{lastTag}'，应为 major.minor.patch")

    try:
        major = int(parts[0])
        minor = int(parts[1])
        patch = int(parts[2])
    except ValueError:
        raise ValueError(f"版本号各部分必须为整数 '{lastTag}'")
        
    if increment_part == 'patch':
        patch += 1
    elif increment_part == 'minor':
        minor += 1
        patch = 0
    elif increment_part == 'major':
        major += 1
        minor = 0
        patch = 0
    else:
        raise ValueError(f"无效的递增部分 '{increment_part}'，应为 'major', 'minor', 或 'patch'")

    return f"{major}.{minor}.{patch}"

def initTagPR():
    try:
        # Git operations
        subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            ["git", "reset", "--hard", f"origin/{argsInfo.projectBranch}"],
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            f"git checkout -B dev-changelog origin/{argsInfo.projectBranch}",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Set DEBEMAIL environment variable
        os.environ["DEBEMAIL"] = argsInfo.debEmail

        lastTag = fetchLastTag()
        logger.info(f"Last Tag: {lastTag}")

        if argsInfo.autoGeneratedProjectTag:
            argsInfo.projectTag = autoGeneratedTagByLastTag(lastTag)
        
        logger.info(f"Project Tag: {argsInfo.projectTag}")

        # Get commit info
        commit_result = subprocess.run(
            ["git", "log", "--pretty=format:%s", "--no-merges", f"{lastTag}..HEAD"],
            check=True,
            capture_output=True,
            text=True
        )
        commitInfo = commit_result.stdout
        if not commitInfo:
            commitInfo = f"Release {argsInfo.projectTag}"

        logger.info(f"Changelog Info: {commitInfo}")

        # Process changelog
        with subprocess.Popen(
            ["xargs", "-d", "\n", "-I", "{}", "dch", "-v", argsInfo.projectTag, "{}"],
            stdin=subprocess.PIPE,
            text=True
        ) as dch_process:
            dch_process.communicate(input=commitInfo)

        subprocess.run(
            "dch -r ''",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Commit changes
        subprocess.run(
            ["git", "commit", "-a", "-m", f"chore: bump version to {argsInfo.projectTag}\n\nupdate changelog to {argsInfo.projectTag}"],
            check=True,
            capture_output=True,
            text=True
        )

    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in initTagPR: {str(e)}")
        raise

def createTagPR():
    try:
        # Check if forked repo exists
        fork_check = subprocess.run(
            ["gh", "repo", "view", f"{argsInfo.githubID}/{argsInfo.projectName}"],
            capture_output=True,
            text=True
        )
        
        if fork_check.returncode != 0:
            # Fork the repo if not exists
            logger.info(f"Forking repository {argsInfo.projectOrg}/{argsInfo.projectName}")
            fork_result = subprocess.run(
                ["gh", "repo", "fork", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "--clone=false"],
                check=True,
                capture_output=True,
                text=True
            )
            logger.debug(f"Fork output: {fork_result.stdout}")

        # Push to github
        push_result = subprocess.run(
            "git push github dev-changelog -f",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Push output: {push_result.stdout}")

        # Prepare PR creation command
        args = [
            "gh", "pr", "create",
            "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}",
            "--head", f"{argsInfo.githubID}:dev-changelog",
            "--base", argsInfo.projectBranch,
            "--title", f"chore: bump version to {argsInfo.projectTag}",
            "--body", f"update changelog to {argsInfo.projectTag}"
        ]
        
        # Add reviewers if specified
        if argsInfo.projectReviewers:
            reviewers = []
            for value in argsInfo.projectReviewers:
                reviewers.extend(['--reviewer', value])
            args.extend(reviewers)
        
        # Create PR
        pr_result = subprocess.run(
            args,
            check=True,
            capture_output=True,
            text=True
        )
        
        # 提取PR链接
        pr_url = pr_result.stdout.strip()
        if pr_url:
            logger.info(f"✅ Successfully created PR for tag {argsInfo.projectTag}")
            logger.info(f"🔗 PR链接: {pr_url}")
            print(f"\n🚀 PR已创建! 请查看: {pr_url}\n")
        else:
            logger.info(f"Successfully created PR for tag {argsInfo.projectTag}")
        
        logger.debug(f"PR creation output: {pr_result.stdout}")
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to create tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in createTagPR: {str(e)}")
        raise

def mergePR():
    try:
        merge_result = subprocess.run(
            ["gh", "pr", "merge", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "-r", f"{argsInfo.githubID}:dev-changelog"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("✅ Successfully merged PR")
        
        # 获取PR链接信息
        try:
            pr_info = subprocess.run(
                ["gh", "pr", "view", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", f"{argsInfo.githubID}:dev-changelog", "--json", "url"],
                capture_output=True,
                text=True
            )
            if pr_info.returncode == 0:
                import json
                pr_data = json.loads(pr_info.stdout)
                pr_url = pr_data.get('url', '')
                if pr_url:
                    logger.info(f"🔗 已合并的PR: {pr_url}")
                    print(f"\n🎉 PR已成功合并! PR链接: {pr_url}\n")
        except:
            pass  # 如果获取失败，不影响主流程
            
        logger.debug(f"Merge output: {merge_result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to merge PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in mergePR: {str(e)}")
        raise

def runRelease():
    """执行GitHub Auto Release workflow"""
    try:
        # 检查gh命令是否可用
        gh_check = subprocess.run(
            ["gh", "--version"],
            capture_output=True,
            text=True
        )
        if gh_check.returncode != 0:
            logger.error("GitHub CLI (gh) is not installed or not available")
            logger.error("Please install GitHub CLI: https://cli.github.com/")
            raise SystemExit(1)

        # 检查是否已登录GitHub
        auth_check = subprocess.run(
            ["gh", "auth", "status"],
            capture_output=True,
            text=True
        )
        if auth_check.returncode != 0:
            logger.error("Not logged in to GitHub")
            logger.error("Please run: gh auth login")
            raise SystemExit(1)

        # 设置默认仓库
        repo_name = f"{argsInfo.projectOrg}/{argsInfo.projectName}"
        logger.info(f"Setting default repository to {repo_name}")

        set_default_result = subprocess.run(
            ["gh", "repo", "set-default", repo_name],
            capture_output=True,
            text=True
        )
        if set_default_result.returncode != 0:
            logger.warning(f"Could not set default repository: {set_default_result.stderr}")
            logger.info("Continuing with explicit repository specification...")

        # 触发Auto Release workflow
        logger.info(f"Triggering 'Auto Release' workflow for {repo_name}")

        workflow_cmd = ["gh", "workflow", "run", "Auto Release"]
        if set_default_result.returncode != 0:
            workflow_cmd.extend(["--repo", repo_name])

        workflow_result = subprocess.run(
            workflow_cmd,
            capture_output=True,
            text=True
        )

        if workflow_result.returncode == 0:
            logger.info("✅ Successfully triggered 'Auto Release' workflow")
            logger.info("🚀 The workflow will automatically create tags and PRs")
            print(f"\n🎉 Auto Release workflow triggered for {repo_name}!")
            print("📋 You can check the workflow status at:")
            print(f"   https://github.com/{repo_name}/actions")
        else:
            logger.error(f"Failed to trigger 'Auto Release' workflow: {workflow_result.stderr}")
            if "could not find workflow" in workflow_result.stderr.lower():
                logger.error("Make sure the 'Auto Release' workflow exists in the repository")
                logger.error("Check: https://github.com/{}/actions".format(repo_name))
            raise SystemExit(1)

    except subprocess.CalledProcessError as e:
        logger.error(f"Command execution failed: {e}")
        logger.error(f"Error output: {e.stderr}")
        raise SystemExit(1)
    except Exception as e:
        logger.error(f"Unexpected error in runRelease: {str(e)}")
        raise SystemExit(1)

def searchProjects():
    """搜索GitHub组织下的项目，支持模糊搜索并按更新时间排序"""
    try:
        # 构建gh命令
        org = argsInfo.projectOrg
        search_query = argsInfo.projectName
        
        if search_query:
            # 使用gh命令进行搜索，按pushedAt排序，过滤包含搜索关键词的项目
            jq_filter = f'.[] | select(.name | test("{search_query}"; "i")) | {{name: .name, pushedAt: .pushedAt, url: .url}}'
        else:
            # 获取所有仓库
            jq_filter = '.[] | {name: .name, pushedAt: .pushedAt, url: .url}'

        # 构建gh命令
        gh_cmd = [
            "gh", "repo", "list", org,
            "--limit", "100",
            "--json", "name,pushedAt,url",
            "--jq", jq_filter
        ]
        
        # 执行gh命令
        result = subprocess.run(
            gh_cmd,
            capture_output=True,
            text=True,
            check=True
        )
        
        # 解析输出
        repos = []
        for line in result.stdout.strip().split('\n'):
            if line.strip():
                try:
                    repo_data = json.loads(line)
                    repos.append(repo_data)
                except json.JSONDecodeError:
                    continue
        
        if not repos:
            return
        
        # 按更新时间排序（最新的在前）
        repos.sort(key=lambda x: x['pushedAt'], reverse=True)
        
        # 直接输出结果，不显示总结信息
        for repo in repos:
            name = repo['name']
            
            if argsInfo.quiet:
                # 静默模式，只输出项目名称
                print(name)
            else:
                # 正常模式，输出时间和项目名称
                pushed_at = repo['pushedAt']
                # 格式化日期
                try:
                    from datetime import datetime
                    # 解析UTC时间并转换为本地时间
                    dt = datetime.fromisoformat(pushed_at.replace('Z', '+00:00'))
                    # 转换为本地时间
                    local_dt = dt.astimezone()
                    formatted_date = local_dt.strftime('%Y-%m-%d %H:%M')
                except:
                    formatted_date = pushed_at[:16].replace('T', ' ')
                
                print(f"{formatted_date:<20} {name:<20} {repo['url']}")
        
    except subprocess.CalledProcessError as e:
        if "authentication required" in e.stderr.lower() or "not logged in" in e.stderr.lower():
            logger.error("Not logged in to GitHub")
            logger.error("Please run: gh auth login")
        elif "organization not found" in e.stderr.lower():
            logger.error(f"Organization '{org}' not found or not accessible")
        else:
            logger.error(f"GitHub CLI error: {e.stderr}")
        raise SystemExit(1)
    except Exception as e:
        logger.error(f"Unexpected error in searchProjects: {str(e)}")
        raise SystemExit(1)

def createOrUpdateRepo():
    dir = os.path.expanduser(argsInfo.projectRootDir)
    if not os.path.exists(dir):
        os.makedirs(dir)

    logger.info(f"Tagging project: {dir}, {argsInfo.projectName}")
    os.chdir(dir)

    if not os.path.exists(dir + "/" + argsInfo.projectName):
        createRepo()
        os.chdir(argsInfo.projectName)
        initRepo()
    else:
        os.chdir(argsInfo.projectName)

def main(argv):
    parser = argparse.ArgumentParser(description='Pack for CRP.')
    parser.add_argument('command', nargs='?', default='tag', choices=['tag', 'merge', 'test', 'lasttag', 'release', 'projects'], help='The command type (list or pack)')

    parser.add_argument('--dir', type=str, default=None, help='The project directory')
    parser.add_argument('--org', type=str, default=None, help='The project organization, e.g: linuxdeepin')
    parser.add_argument('--name', type=str, default=None, help='The project name')
    parser.add_argument('--branch', type=str, default=None, help='The project branch')
    parser.add_argument('--tag', type=str, default=None, help='The project tag')
    parser.add_argument('--reviewer', type=str, default=[], nargs='+', help='The project reviewers')
    parser.add_argument('--verbose', action='store_true', help='Show verbose output for git operations')
    parser.add_argument('--quiet', action='store_true', help='Show brief output results')

    if "DEBEMAIL" not in os.environ:
        os.environ["DEBEMAIL"] = argsInfo.debEmail

    args = parser.parse_args()

    if (args.name is not None):
        argsInfo.projectName = args.name
    elif (args.command == 'projects'):
        # projects命令如果没有提供name参数，则清空搜索关键词
        argsInfo.projectName = ""
    if (args.branch is not None):
        argsInfo.projectBranch = args.branch
    if (args.tag is not None):
        argsInfo.projectTag = args.tag
    else:
        argsInfo.autoGeneratedProjectTag = True
    if (args.dir is not None):
        argsInfo.projectRootDir = args.dir
    if (args.org is not None):
        argsInfo.projectOrg = args.org
    reviewers = args.reviewer
    if len(reviewers) > 0:
        argsInfo.projectReviewers = reviewers
    argsInfo.verbose = args.verbose
    argsInfo.quiet = args.quiet

    if (args.command == 'release'):
        # release命令不需要createOrUpdateRepo，直接执行
        runRelease()
    elif (args.command == 'projects'):
        # projects命令不需要createOrUpdateRepo，直接搜索项目
        searchProjects()
    else:
        createOrUpdateRepo()
        if (args.command == 'merge'):
            mergePR()
        elif (args.command == 'test'):
            initTagPR()
            try:
                diff_result = subprocess.run(
                    "git diff HEAD^ HEAD | cat",
                    shell=True,
                    check=True,
                    capture_output=True,
                    text=True
                )
                print(diff_result.stdout)
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to show diff: {e.stderr}")
        elif (args.command == 'lasttag'):
            lastTag = fetchLastTag()
            logger.info(f"Last Tag: {lastTag}")
        else:
            initTagPR()
            createTagPR()

if(__name__=="__main__"):
    main(sys.argv)
