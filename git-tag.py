import sys
import argparse
import subprocess
import re
import os
import logging
import json
from datetime import datetime

class Colors:
    RESET = '\033[0m'
    RED = '\033[31m'      # ÈîôËØØ
    YELLOW = '\033[33m'   # Ë≠¶Âëä
    GREEN = '\033[32m'    # ÊàêÂäü‰ø°ÊÅØ
    GRAY = '\033[90m'     # Ë∞ÉËØï‰ø°ÊÅØ

class ColoredFormatter(logging.Formatter):
    COLORS = {
        logging.ERROR: Colors.RED,
        logging.WARNING: Colors.YELLOW,
        logging.INFO: Colors.GREEN,
        logging.DEBUG: Colors.GRAY,
    }

    def format(self, record):
        # ÂÖàÊ†ºÂºèÂåñÊ∂àÊÅØ
        formatted = super().format(record)
        
        # Âè™Âú®ÁªàÁ´Ø‰∏≠ÊòæÁ§∫È¢úËâ≤ÔºåÊï¥Ë°åÂ∫îÁî®È¢úËâ≤
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            color = self.COLORS.get(record.levelno, '')
            if color:
                formatted = f"{color}{formatted}{Colors.RESET}"
        
        return formatted

# ÂÖ®Â±ÄÂèÇÊï∞
class ArgsInfo:
    def __init__(self):
        # ÈªòËÆ§ÂÄº
        self.projectName = "xxxtools" # È°πÁõÆÂêçÁß∞
        self.projectBranch = "master" # È°πÁõÆÂàÜÊîØ
        self.projectTag = "1.0.0" # Ëá™ÂÆö‰πâtag
        self.autoGeneratedProjectTag = False # tagÊòØÂê¶Ëá™Âä®ÁîüÊàê
        self.projectOrg = "linuxdeepin"
        self.projectReviewers = []
        self.verbose = False # ÊòØÂê¶ÊòæÁ§∫ËØ¶ÁªÜËæìÂá∫
        # ‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñÂèÇÊï∞
        self.projectRootDir = "~/.cache/git-tag-dir" # ÈªòËÆ§ÂÄº
        config_path = os.path.expanduser('~/.config/dev-tool/git-tag-config.json')
        with open(config_path) as f:
            config = json.load(f)
        
        # Git‰ø°ÊÅØ
        self.githubID = config['git']['githubID']     # github Áî®Êà∑id
        self.debEmail = config['git']['debEmail']     # debian ÊâìÂåÖÈÇÆÁÆ±

        # ‰ªéÈÖçÁΩÆÊñá‰ª∂‰∏≠ËØªÂèñÂÖ∂‰ªñÂèÇÊï∞ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if 'params' in config:
            params = config['params']
            self.projectBranch = params.get('projectBranch', self.projectBranch)
            self.projectOrg = params.get('projectOrg', self.projectOrg)
            self.projectReviewers = params.get('projectReviewers', self.projectReviewers)
            self.projectRootDir = params.get('projectRootDir', self.projectRootDir)

argsInfo = ArgsInfo()

def setup_logging():
    level = logging.DEBUG if argsInfo.verbose else logging.INFO
    
    # ÂàõÂª∫logger
    logger = logging.getLogger(__name__)
    logger.setLevel(level)
    
    # ÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†handler
    if logger.handlers:
        logger.handlers.clear()
    
    # ÂàõÂª∫ÊéßÂà∂Âè∞Â§ÑÁêÜÂô®
    handler = logging.StreamHandler()
    handler.setLevel(level)
    
    # ‰ΩøÁî®ÂΩ©Ëâ≤Ê†ºÂºèÂåñÂô®
    formatter = ColoredFormatter(
        fmt='[%(asctime)s] [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    logger.addHandler(handler)
    return logger

def find_config_file(filename):
    """Êü•ÊâæÈÖçÁΩÆÊñá‰ª∂ÔºåÂÖàÂú®ÂΩìÂâçÁõÆÂΩïÊü•ÊâæÔºåÁÑ∂ÂêéÂú®~/.config/dev-tool/packagesÊü•Êâæ"""
    # Ê£ÄÊü•ÂΩìÂâçÁõÆÂΩï
    local_path = os.path.join(os.getcwd(), filename)
    if os.path.exists(local_path):
        return local_path
    
    # Ê£ÄÊü•packagesÁõÆÂΩï
    packages_path = os.path.expanduser(f'~/.config/dev-tool/packages/{filename}')
    if os.path.exists(packages_path):
        return packages_path
    
    # Ê£ÄÊü•ÈªòËÆ§configÁõÆÂΩï
    config_path = os.path.expanduser(f'~/.config/dev-tool/{filename}')
    if os.path.exists(config_path):
        return config_path
    
    raise FileNotFoundError(f"Could not find config file {filename} in any of: current directory, ~/.config/dev-tool/packages/, ~/.config/dev-tool/")

logger = setup_logging()

def createRepo():
    try:
        result = subprocess.run(
            ["git", "clone", "https://github.com/" + argsInfo.projectOrg + "/" + argsInfo.projectName + ".git"],
            check=True,
            capture_output=not argsInfo.verbose,
            text=True
        )
        logger.info(f"Successfully cloned repository: {argsInfo.projectOrg}/{argsInfo.projectName}")
        if not argsInfo.verbose:
            logger.debug(f"Clone output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to clone repository {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.error(f"Error: {e.stderr}")
        raise

def initRepo():
    try:
        # Add github remote
        result = subprocess.run(
            f"git remote add github https://github.com/{argsInfo.githubID}/{argsInfo.projectName}.git",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("Successfully added github remote")
        logger.debug(f"Add remote output: {result.stdout}")

        # Set default repo
        result = subprocess.run(
            ["gh", "repo", "set-default", f"{argsInfo.projectOrg}/{argsInfo.projectName}"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info(f"Successfully set default repository to {argsInfo.projectOrg}/{argsInfo.projectName}")
        logger.debug(f"Set default repo output: {result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize repository: {e.stderr}")
        raise
    
def fetchLastTag():
    try:
        # Fetch from origin
        fetch_result = subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Fetch output: {fetch_result.stdout}")

        # Get last tag
        tag_result = subprocess.run(
            "git describe --tags --abbrev=0",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        lastTag = tag_result.stdout.strip()
        logger.info(f"Found last tag: {lastTag}")
        return lastTag
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to fetch/get last tag: {e.stderr}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error in fetchLastTag: {str(e)}")
        return None

def autoGeneratedTagByLastTag(lastTag):
    increment_part = 'patch'  # ÈªòËÆ§ÈÄíÂ¢ûÈÉ®ÂàÜ‰∏∫ 'patch' {major}.{minor}.{patch}
    parts = lastTag.split('.')
    if len(parts) != 3:
        raise ValueError(f"Êó†ÊïàÁöÑÁâàÊú¨Âè∑Ê†ºÂºè '{lastTag}'ÔºåÂ∫î‰∏∫ major.minor.patch")

    try:
        major = int(parts[0])
        minor = int(parts[1])
        patch = int(parts[2])
    except ValueError:
        raise ValueError(f"ÁâàÊú¨Âè∑ÂêÑÈÉ®ÂàÜÂøÖÈ°ª‰∏∫Êï¥Êï∞ '{lastTag}'")
        
    if increment_part == 'patch':
        patch += 1
    elif increment_part == 'minor':
        minor += 1
        patch = 0
    elif increment_part == 'major':
        major += 1
        minor = 0
        patch = 0
    else:
        raise ValueError(f"Êó†ÊïàÁöÑÈÄíÂ¢ûÈÉ®ÂàÜ '{increment_part}'ÔºåÂ∫î‰∏∫ 'major', 'minor', Êàñ 'patch'")

    return f"{major}.{minor}.{patch}"

def initTagPR():
    try:
        # Git operations
        subprocess.run(
            "git fetch origin",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            ["git", "reset", "--hard", f"origin/{argsInfo.projectBranch}"],
            check=True,
            capture_output=True,
            text=True
        )
        
        subprocess.run(
            f"git checkout -B dev-changelog origin/{argsInfo.projectBranch}",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Set DEBEMAIL environment variable
        os.environ["DEBEMAIL"] = argsInfo.debEmail

        lastTag = fetchLastTag()
        logger.info(f"Last Tag: {lastTag}")

        if argsInfo.autoGeneratedProjectTag:
            argsInfo.projectTag = autoGeneratedTagByLastTag(lastTag)
        
        logger.info(f"Project Tag: {argsInfo.projectTag}")

        # Get commit info
        commit_result = subprocess.run(
            ["git", "log", "--pretty=format:%s", "--no-merges", f"{lastTag}..HEAD"],
            check=True,
            capture_output=True,
            text=True
        )
        commitInfo = commit_result.stdout
        if not commitInfo:
            commitInfo = f"Release {argsInfo.projectTag}"

        logger.info(f"Changelog Info: {commitInfo}")

        # Process changelog
        with subprocess.Popen(
            ["xargs", "-d", "\n", "-I", "{}", "dch", "-v", argsInfo.projectTag, "{}"],
            stdin=subprocess.PIPE,
            text=True
        ) as dch_process:
            dch_process.communicate(input=commitInfo)

        subprocess.run(
            "dch -r ''",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )

        # Commit changes
        subprocess.run(
            ["git", "commit", "-a", "-m", f"chore: bump version to {argsInfo.projectTag}\n\nupdate changelog to {argsInfo.projectTag}"],
            check=True,
            capture_output=True,
            text=True
        )

    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to initialize tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in initTagPR: {str(e)}")
        raise

def createTagPR():
    try:
        # Check if forked repo exists
        fork_check = subprocess.run(
            ["gh", "repo", "view", f"{argsInfo.githubID}/{argsInfo.projectName}"],
            capture_output=True,
            text=True
        )
        
        if fork_check.returncode != 0:
            # Fork the repo if not exists
            logger.info(f"Forking repository {argsInfo.projectOrg}/{argsInfo.projectName}")
            fork_result = subprocess.run(
                ["gh", "repo", "fork", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "--clone=false"],
                check=True,
                capture_output=True,
                text=True
            )
            logger.debug(f"Fork output: {fork_result.stdout}")

        # Push to github
        push_result = subprocess.run(
            "git push github dev-changelog -f",
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        logger.debug(f"Push output: {push_result.stdout}")

        # Prepare PR creation command
        args = [
            "gh", "pr", "create",
            "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}",
            "--head", f"{argsInfo.githubID}:dev-changelog",
            "--base", argsInfo.projectBranch,
            "--title", f"chore: bump version to {argsInfo.projectTag}",
            "--body", f"update changelog to {argsInfo.projectTag}"
        ]
        
        # Add reviewers if specified
        if argsInfo.projectReviewers:
            reviewers = []
            for value in argsInfo.projectReviewers:
                reviewers.extend(['--reviewer', value])
            args.extend(reviewers)
        
        # Create PR
        pr_result = subprocess.run(
            args,
            check=True,
            capture_output=True,
            text=True
        )
        
        # ÊèêÂèñPRÈìæÊé•
        pr_url = pr_result.stdout.strip()
        if pr_url:
            logger.info(f"‚úÖ Successfully created PR for tag {argsInfo.projectTag}")
            logger.info(f"üîó PRÈìæÊé•: {pr_url}")
            print(f"\nüöÄ PRÂ∑≤ÂàõÂª∫! ËØ∑Êü•Áúã: {pr_url}\n")
        else:
            logger.info(f"Successfully created PR for tag {argsInfo.projectTag}")
        
        logger.debug(f"PR creation output: {pr_result.stdout}")
        
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to create tag PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in createTagPR: {str(e)}")
        raise

def mergePR():
    try:
        merge_result = subprocess.run(
            ["gh", "pr", "merge", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", "-r", f"{argsInfo.githubID}:dev-changelog"],
            check=True,
            capture_output=True,
            text=True
        )
        logger.info("‚úÖ Successfully merged PR")
        
        # Ëé∑ÂèñPRÈìæÊé•‰ø°ÊÅØ
        try:
            pr_info = subprocess.run(
                ["gh", "pr", "view", "--repo", f"{argsInfo.projectOrg}/{argsInfo.projectName}", f"{argsInfo.githubID}:dev-changelog", "--json", "url"],
                capture_output=True,
                text=True
            )
            if pr_info.returncode == 0:
                import json
                pr_data = json.loads(pr_info.stdout)
                pr_url = pr_data.get('url', '')
                if pr_url:
                    logger.info(f"üîó Â∑≤ÂêàÂπ∂ÁöÑPR: {pr_url}")
                    print(f"\nüéâ PRÂ∑≤ÊàêÂäüÂêàÂπ∂! PRÈìæÊé•: {pr_url}\n")
        except:
            pass  # Â¶ÇÊûúËé∑ÂèñÂ§±Ë¥•Ôºå‰∏çÂΩ±Âìç‰∏ªÊµÅÁ®ã
            
        logger.debug(f"Merge output: {merge_result.stdout}")
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to merge PR: {e.stderr}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in mergePR: {str(e)}")
        raise

def runRelease():
    """ÊâßË°åGitHub Auto Release workflow"""
    try:
        # Ê£ÄÊü•ghÂëΩ‰ª§ÊòØÂê¶ÂèØÁî®
        gh_check = subprocess.run(
            ["gh", "--version"],
            capture_output=True,
            text=True
        )
        if gh_check.returncode != 0:
            logger.error("GitHub CLI (gh) is not installed or not available")
            logger.error("Please install GitHub CLI: https://cli.github.com/")
            raise SystemExit(1)

        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁôªÂΩïGitHub
        auth_check = subprocess.run(
            ["gh", "auth", "status"],
            capture_output=True,
            text=True
        )
        if auth_check.returncode != 0:
            logger.error("Not logged in to GitHub")
            logger.error("Please run: gh auth login")
            raise SystemExit(1)

        # ËÆæÁΩÆÈªòËÆ§‰ªìÂ∫ì
        repo_name = f"{argsInfo.projectOrg}/{argsInfo.projectName}"
        logger.info(f"Setting default repository to {repo_name}")

        set_default_result = subprocess.run(
            ["gh", "repo", "set-default", repo_name],
            capture_output=True,
            text=True
        )
        if set_default_result.returncode != 0:
            logger.warning(f"Could not set default repository: {set_default_result.stderr}")
            logger.info("Continuing with explicit repository specification...")

        # Ëß¶ÂèëAuto Release workflow
        logger.info(f"Triggering 'Auto Release' workflow for {repo_name}")

        workflow_cmd = ["gh", "workflow", "run", "Auto Release"]
        if set_default_result.returncode != 0:
            workflow_cmd.extend(["--repo", repo_name])

        workflow_result = subprocess.run(
            workflow_cmd,
            capture_output=True,
            text=True
        )

        if workflow_result.returncode == 0:
            logger.info("‚úÖ Successfully triggered 'Auto Release' workflow")
            logger.info("üöÄ The workflow will automatically create tags and PRs")
            print(f"\nüéâ Auto Release workflow triggered for {repo_name}!")
            print("üìã You can check the workflow status at:")
            print(f"   https://github.com/{repo_name}/actions")
        else:
            logger.error(f"Failed to trigger 'Auto Release' workflow: {workflow_result.stderr}")
            if "could not find workflow" in workflow_result.stderr.lower():
                logger.error("Make sure the 'Auto Release' workflow exists in the repository")
                logger.error("Check: https://github.com/{}/actions".format(repo_name))
            raise SystemExit(1)

    except subprocess.CalledProcessError as e:
        logger.error(f"Command execution failed: {e}")
        logger.error(f"Error output: {e.stderr}")
        raise SystemExit(1)
    except Exception as e:
        logger.error(f"Unexpected error in runRelease: {str(e)}")
        raise SystemExit(1)

def createOrUpdateRepo():
    dir = os.path.expanduser(argsInfo.projectRootDir)
    if not os.path.exists(dir):
        os.makedirs(dir)

    logger.info(f"Tagging project: {dir}, {argsInfo.projectName}")
    os.chdir(dir)

    if not os.path.exists(dir + "/" + argsInfo.projectName):
        createRepo()
        os.chdir(argsInfo.projectName)
        initRepo()
    else:
        os.chdir(argsInfo.projectName)

def main(argv):
    parser = argparse.ArgumentParser(description='Pack for CRP.')
    parser.add_argument('command', nargs='?', default='tag', choices=['tag', 'merge', 'test', 'lasttag', 'release'], help='The command type (list or pack)')

    parser.add_argument('--dir', type=str, default=None, help='The project directory')
    parser.add_argument('--org', type=str, default=None, help='The project organization, e.g: linuxdeepin')
    parser.add_argument('--name', type=str, default=None, help='The project name')
    parser.add_argument('--branch', type=str, default=None, help='The project branch')
    parser.add_argument('--tag', type=str, default=None, help='The project tag')
    parser.add_argument('--reviewer', type=str, default=[], nargs='+', help='The project reviewers')
    parser.add_argument('--verbose', action='store_true', help='Show verbose output for git operations')

    if "DEBEMAIL" not in os.environ:
        os.environ["DEBEMAIL"] = argsInfo.debEmail

    args = parser.parse_args()

    if (args.name is not None):
        argsInfo.projectName = args.name
    if (args.branch is not None):
        argsInfo.projectBranch = args.branch
    if (args.tag is not None):
        argsInfo.projectTag = args.tag
    else:
        argsInfo.autoGeneratedProjectTag = True
    if (args.dir is not None):
        argsInfo.projectRootDir = args.dir
    if (args.org is not None):
        argsInfo.projectOrg = args.org
    reviewers = args.reviewer
    if len(reviewers) > 0:
        argsInfo.projectReviewers = reviewers
    argsInfo.verbose = args.verbose

    if (args.command == 'release'):
        # releaseÂëΩ‰ª§‰∏çÈúÄË¶ÅcreateOrUpdateRepoÔºåÁõ¥Êé•ÊâßË°å
        runRelease()
    else:
        createOrUpdateRepo()
        if (args.command == 'merge'):
            mergePR()
        elif (args.command == 'test'):
            initTagPR()
            try:
                diff_result = subprocess.run(
                    "git diff HEAD^ HEAD | cat",
                    shell=True,
                    check=True,
                    capture_output=True,
                    text=True
                )
                print(diff_result.stdout)
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to show diff: {e.stderr}")
        elif (args.command == 'lasttag'):
            lastTag = fetchLastTag()
            logger.info(f"Last Tag: {lastTag}")
        else:
            initTagPR()
            createTagPR()

if(__name__=="__main__"):
    main(sys.argv)
